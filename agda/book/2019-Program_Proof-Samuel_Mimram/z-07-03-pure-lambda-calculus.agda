module z-07-03-pure-lambda-calculus where

open import Data.Bool        hiding (if_then_else_ ; _≟_ ; _<_ ; _<?_)
open import Data.Empty
open import Data.Maybe
open import Data.Nat         renaming (_+_ to _+ℕ_ ; _<?_ to _<?ℕ_) hiding (_<_)
open import Data.Sum
open import Data.Unit
open import Function
open import Relation.Binary.PropositionalEquality
open import Relation.Nullary

{-
------------------------------------------------------------------------------
-- 7.3 Pure λ-calculus

using de Bruijn indices.

7.3.1 Naive approach. directly translating λ-terms given in section 3.1

Var : Set
Var = String

-- syntax of λ-terms
data Tm : Set where
  var  : Var      → Tm -- variable
  _·_  : Tm  → Tm → Tm -- application
  ƛ_,_ : Var → Tm → Tm -- abstraction

could proceed with above, but remember that λ-terms are not terms generated by the above syntax,
but rather of the quotient under α-equivalence (section 3.1.3).
This means that we will have to define this equivalence
and show that all the constructions to be made are compatible with it.
Long and painful.

TODO
Exercise 7.3.1.1. Try to properly define β-reduction with this formalization.


7.3.2 De Bruijn indices.
To handle the α-conversion problem, use de Bruijn indices for variables (see 3.6.2)
-}

data Tm : Set where
  var : ℕ       → Tm -- the x-th variable with x a natural number
  _·_ : Tm → Tm → Tm -- t · u : application of term t to term u
  ƛ_  : Tm → Tm      -- ƛ t : abstraction of the 0-th variable in t

{-
Before defining β-reduction, define functions to manipulate variables (see 3.6.2)
LIFTING : creating a fresh variable numbered x.
After performing this operation, all variable indices y which are greater than x
have to be increased by one in order to make room for x.
The new index of y after the creation of x is defined:
                 y     if y < x
         ↑ₓy  =
                 y + 1 if y > x
-}
↑ : ℕ → ℕ → ℕ
↑  zero        y  = suc y
↑ (suc x)  zero   = zero
↑ (suc x) (suc y) = suc (↑ x y)
{-
UNLIFTING : removing an unused variable.
After removal, all variable indices y > x have to be decreased by one
in order to fill in the “empty space” left by x.

               y     if y < x
         ↓ₓy =
               y − 1 if y > x

The function is not defined when y = x, because we have supposed that the
variable x is not used.
-}
↓ : (x y : ℕ) → x ≢ y → ℕ
↓  zero    zero   ¬p = ⊥-elim (¬p refl)
↓  zero   (suc y) ¬p = y
↓ (suc x)  zero   ¬p = zero
↓ (suc x) (suc y) ¬p = suc (↓ x y (λ p → ¬p (cong suc p)))

{-
Lifting extended to λ-terms.
Given var x and λ-term t, term ↑ₓt obtained after creating a fresh variable x, written wk x t
- thought of as weakening for term t

Definition uses lifting on variables,
recursively applies weakening for applications and abstractions.
Subtlety for last case
- since abstraction binds the variable 0 in a term t,
  a variable x in λ.t corresponds to a the variable x + 1 in t,
  explains the need to increase the weakened variable by one when going under abstractions.
-}

wk : ℕ → Tm → Tm
wk x (var  y) = var (↑ x y)
wk x (t · t') = wk x t · wk x t'
wk x (ƛ    t) = ƛ (wk (suc x) t)

-- TODO
















