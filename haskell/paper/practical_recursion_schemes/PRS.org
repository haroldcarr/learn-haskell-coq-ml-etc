#+TITLE:       Practical Recursion Schemes
#+AUTHOR:      Jared Tobin (condensed by Harold Carr)
#+DESCRIPTION: practical recursion schemes
#+PROPERTY:    tangle PRS.hs
#+OPTIONS:     num:nil toc:t
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

#+BEGIN_HTML
---
title: practical recursion schemes
tags: haskell, recursion
---
#+END_HTML

------------------------------------------------------------------------------
* intro

Edward Kmett’s recursion-schemes library

key patterns
- factoring recursion out of your data types using pattern functors and a fixed-point wrapper
  - benefits: ability to reason about recursion and base structures separately
- using the ‘Foldable’ & ‘Unfoldable’ classes
- navigating the ‘Base’ type family

‘hacking understanding’ : help see similarities in structure between domains

requirements
- GHC 7.10.2
- recursion-schemes-4.1.2
- data-ordlist-0.4.7.0

#+BEGIN_SRC haskell
{-# LANGUAGE DeriveFunctor #-}

module PRS where

import Data.Functor.Foldable
import Data.List.Ordered (merge)
import Prelude hiding (Foldable, succ)
#+END_SRC

applicable to data types that have a recursive structure (e.g., Lists, trees, nats)

#+BEGIN_SRC haskell
data Natural =
    Zero
  | Succ Natural
#+END_SRC

‘factor out’ recursion by defining some base structure
- create a different, parameterized type
- new parameter takes place of all recursive points in original

#+BEGIN_SRC haskell
data NatF r =
    ZeroF
  | SuccF r
  deriving (Show, Functor)
#+END_SRC

must be a functor - type often called a ‘pattern functor’ for some other type

personal notation ‘<Constructor>F’ for pattern functors constructors

example lists and trees:

#+BEGIN_SRC haskell
data ListF a r =
    NilF
  | ConsF a r
  deriving (Show, Functor)

data TreeF a r =
    EmptyF
  | LeafF a
  | NodeF r r
  deriving (Show, Functor)
#+END_SRC

to add recursion to pattern functors via a recursive 'Fix' wrapper type

#+BEGIN_SRC haskell
type Nat    = Fix NatF
type List a = Fix (ListF a)
type Tree a = Fix (TreeF a)
#+END_SRC

‘Fix’ from ‘Data.Functor.Foldable’ (recursion-schemes).

personal style: use smart constructors:

#+BEGIN_SRC haskell
zero :: Nat
zero = Fix ZeroF
succ :: Nat -> Nat
succ = Fix . SuccF
nil :: List a
nil = Fix NilF
cons :: a -> List a -> List a
cons x xs = Fix (ConsF x xs)
#+END_SRC

enables:

#+BEGIN_EXAMPLE
> succ (succ (succ zero))
Fix (SuccF (Fix (SuccF (Fix (SuccF (Fix ZeroF))))))
#+END_EXAMPLE

Fix definition

#+BEGIN_EXAMPLE
newtype Fix f = Fix (f (Fix f))
fix :: f -> Fix f
fix = Fix
unfix :: Fix f -> f (Fix f)
unfix (Fix f) = f
#+END_EXAMPLE

For given value
- 'fix’ adds one level of recursion
- ‘unfix’ removes one level of recursion

'Fix' is "generic" recursive structure
- write recursive type without using recursion
- use ‘Fix’ to add recursion

------------------------------------------------------------------------------
* Recursion Schemes

Wrap pattern functor in ‘Fix’, then recursion-schemes functions ‘just work’.

two fundamental type classes

- ‘Foldable’
  - types that can be ‘unfixed’ : remove layers of recursion from instances
  - ‘project’ : more general form of 'unfix'
#+BEGIN_EXAMPLE
project :: Foldable t   => t -> Base t t
#+END_EXAMPLE
- ‘Unfoldable’
  - types that can be   ‘fixed’ : add    layers of recursion to instances
  - ‘embed’   : more general form of   'fix'
#+BEGIN_EXAMPLE
embed   :: Unfoldable t => Base t t -> t
#+END_EXAMPLE

‘Base’ appears frequently in type signatures of various recursion schemes

------------------------------------------------------------------------------
* ‘Base’ and Basic Type Families

Type families are type-level functions
- types as input
- return types as output

#+BEGIN_EXAMPLE
-- fun takes type ‘t’ as input, returns some other type
type family Base t :: * -> *
#+END_EXAMPLE

Implementation of this function is called an instance of the family (e.g., instance for ‘Fix’):

#+BEGIN_EXAMPLE
type instance Base (Fix f) = f
#+END_EXAMPLE

Type family (like ‘Base’) is a synonym for instances of the family.
- e.g., mentally replace ‘Base (Fix f)’ with ‘f’

Instances of ‘Base’ type family have structure like ‘Fix’
- using ‘Base’ enables recursion-schemes to work for types other than ‘Fix’ alone
  - without needing to manually write any instances for your own data types
  - you can leverage typeclasses & type families to get by without using ‘Fix’ at all
    - e.g., Danny Gratzer’s recursion-schemes post
      - [[http://jozefg.bitbucket.org/posts/2014-05-19-like-recursion-but-cooler.html]]
- Kmettian flavour
  - first solve most general problem
  - then recover specific solutions

‘Fix f’ is an instance of ‘Base’, ‘Foldable’, and ‘Unfoldable’ for some functor ‘f’

------------------------------------------------------------------------------
* Useful Schemes

- catamorphisms : ‘cata’ : generalized folds.
- anamorphisms  : ‘ana’  : generalized unfolds.
- hylomorphisms : ‘hylo’ : anamorphisms followed by catamorphisms
                           (corecursive production followed by recursive consumption)
- paramorphisms : ‘para’ : generalized folds with access to input arg
                           corresponding to most recent state of computation

(see Tim Williams’s recursion schemes for discussion of other schemes
[[http://www.timphilipwilliams.com/slides.html]])

# --------------------------------------------------
** Catamorphisms

*** Use catamorphism to represent ‘Nat’ as ‘Int’ via summing

#+BEGIN_SRC haskell
natsum :: Nat -> Int
natsum = cata alg where
  alg ZeroF     = 0
  alg (SuccF n) = n + 1
#+END_SRC

‘alg’ (i.e., ‘algebra’) is local fun to define reduction semantics.

NOTE: SEMANTICS ARE NOT DEFINED RECURSIVELY.

Recursion in ‘Nat’ has been decoupled and handled by ‘cata’.

And don’t have to use ‘Fix’ constructor.

Another way to express:

#+BEGIN_EXAMPLE
{-# LANGUAGE LambdaCase #-}
natsum :: Nat -> Int
natsum = cata $ \case ->
  ZeroF   -> 0
  SuccF n -> n + 1
#+END_EXAMPLE

#+BEGIN_EXAMPLE
-- ‘Base t a -> a’ is the algebra
-- ‘t’ is recursive datatype (i.e. ‘Nat’)
-- ‘a’ is type that 't' is being reduced to
cata :: Foldable t => (Base t a -> a) -> t -> a
#+END_EXAMPLE

‘Base’ is a type family, so for some ‘t’ and ‘a’.

‘Base t a’ is a synonym for some other type.

To figure out what ‘Base t a’ corresponds to for some concrete ‘t’ and ‘a’:

#+BEGIN_EXAMPLE
> :kind! Base Nat Int
Base Nat Int :: *
= NatF Int
#+END_EXAMPLE

For the ‘natsum’ example, algebra used with ‘cata’ is ‘NatF Int -> Int’.

*** catamorphism to implement ‘filter’ for list type

#+BEGIN_SRC haskell
filterL :: (a -> Bool) -> List a -> List a
filterL p = cata alg where
  alg NilF = nil
  alg (ConsF x xs)
    | p x       = cons x xs
    | otherwise = xs
#+END_SRC

# --------------------------------------------------
** Anamorphisms

*** anamorphism to build ‘Nat’ from ‘Int’

#+BEGIN_SRC haskell
nat :: Int -> Nat
nat = ana coalg where
  coalg n
    | n <= 0    = ZeroF
    | otherwise = SuccF (n - 1)
#+END_SRC

‘coalg’ (i.e., ‘coalgebra’)

Recursion is not part of the semantics.

# --------------------------------------------------
** Paramorphisms

*** factorial on nat in terms of ‘cata’

paramorphism operates on algebra that provides access to input arg
corresponding to running state of the recursion:

#+BEGIN_EXAMPLE
para :: Foldable t => (Base t (t, a) -> a) -> t -> a
#+END_EXAMPLE

For factorial on ‘Nat’ values
- ‘t’ is ‘Nat’
- ‘a’ is (say) ‘Integer’

#+BEGIN_EXAMPLE
> :kind! Base Nat (Nat, Int)
Base Nat (Nat, Int) :: *
= NatF (Nat, Int)
#+END_EXAMPLE

now implement algebra for the required type:

#+BEGIN_SRC haskell
natfac :: Nat -> Int
natfac = para alg where
  alg  ZeroF         = 1
  alg (SuccF (n, f)) = natsum (succ n) * f
#+END_SRC

- type of algebra is ‘NatF (Nat, Int) -> Int’
- value with the ‘Nat’ type, ‘n’,
  holds most recent input arg used to compute state of computation, ‘f’

For factorial defined as

#+BEGIN_EXAMPLE
0!       = 1
(k + 1)! = (k + 1) * k!
#+END_EXAMPLE

- ‘n’ corresponds to ‘k’
- ‘f’ corresponds to ‘k!’

To compute factorial of successor to ‘n’
- convert ‘succ n’ to an integer (via ‘natsum’) and multiply it by ‘f’

*** ‘pred’ on natural numbers via ‘para’:

#+BEGIN_SRC haskell
natpred :: Nat -> Nat
natpred = para alg where
  alg ZeroF          = zero
  alg (SuccF (n, _)) = n
#+END_SRC

*** ‘tail’ on lists

type of required algebra:

#+BEGIN_EXAMPLE
> :set -XRankNTypes
> :kind! forall a b. Base (List a) (List a, b)
forall a b. Base (List a) (List a, b) :: *
= forall a b. ListF a (Fix (ListF a), b)
#+END_EXAMPLE

therefore:

#+BEGIN_SRC haskell
tailL :: List a -> List a
tailL = para alg where
  alg NilF             = nil
  alg (ConsF _ (l, _)) = l
#+END_SRC

# --------------------------------------------------
** Hylomorphisms

Hylomorphisms can express general computation
— corecursive production followed by recursive consumption

#+BEGIN_EXAMPLE
hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
#+END_EXAMPLE

Does not require the full structure built up for i.e. ‘cata’ and ‘ana’.

A simple F-{co}algebras.

*** hylomorphism implementation of mergesort

- input : list containing orderable type
- build balanced binary tree via anamorphism
- fold it with a catamorphism
  - merging lists together and sorting as it goes

#+BEGIN_SRC haskell
mergeSort :: Ord a => [a] -> [a]
mergeSort = hylo alg coalg where
  alg EmptyF      = []
  alg (LeafF c)   = [c]
  alg (NodeF l r) = merge l r
  coalg []  = EmptyF
  coalg [x] = LeafF x
  coalg xs  = NodeF l r where
    (l, r) = splitAt (length xs `div` 2) xs
#+END_SRC

Note the fusion.

------------------------------------------------------------------------------
* conclusion

Haskell programming
- embedded languages, mini-interpreters/compilers
- recursive structure: use above

[[http://www.timphilipwilliams.com/slides.html]]

[[https://www.youtube.com/watch?v=Zw9KeP3OzpU]]

